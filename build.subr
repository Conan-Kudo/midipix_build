#
# . ./build.vars and set -o errexit are assumed.
# See warning at the top of build.vars.
#

date() { command date +"${1:-${TIMESTAMP_FMT}}"; };
get_basename() { set -- $(get_name_without_slash ${1}); echo "${1##*/}"; };
get_var_dyn() { ${1}; };
get_var_unsafe() { eval echo \${${1}}; };
set_var_dyn() { eval ${1}\(\) \{ echo \"${2}\"\; \}; };
set_var_unsafe() { eval ${1}=\"${2}\"; };
get_name_without_slash() { while [ "${1%/}" != ${1} ]; do set -- ${1%/}; done; echo ${1}; };
get_postfix_lrg() { echo "${1##*${2}}"; };
get_prefix_lrg() { echo "${1%%${2}*}"; };
get_postfix() { echo "${1#*${2}}"; };
get_prefix() { echo "${1%${2}*}"; };
match_any() { [ "${1#*${2}*}" != "${1}" ]; };
match_uname_any() { set -- ${1} $(uname -s); [ "${2#*${1}*}" != "${2}" ]; };
push_IFS() { _pI_IFS="${IFS}"; IFS="${1}"; };
pop_IFS() { IFS="${_pI_IFS}"; unset _pI_IFS; };
set_build_dir() { PKG_BUILD_DIR=${1}-${2}-${TARGET}; };
split() { push_IFS "${1}"; set -- ${2}; pop_IFS; echo "${*}"; };
test_cmd() { command -v "${1}" >/dev/null; };
unsplit() { push_IFS "${1}"; shift; set -- "${@}"; echo "${*}"; pop_IFS; };


build_times_init() { BUILD_TIMES_SECS=$(command date +%s); };
build_times_get() {
	: $((BUILD_TIMES_SECS=$(command date +%s)-${BUILD_TIMES_SECS}));
	: $((BUILD_TIMES_HOURS=${BUILD_TIMES_SECS}/3600));
	: $((BUILD_TIMES_MINUTES=(${BUILD_TIMES_SECS}%3600)/60));
	: $((BUILD_TIMES_SECS=(${BUILD_TIMES_SECS}%3600)%60));
};

clean_prefix() {
	log_msg info "-c specified, cleaning prefix...";
	set -- bin include lib lib64 libexec native share x86_64-nt64-midipix;
	while [ ${#} -gt 0 ]; do rm -rf ${PREFIX}/${1}; shift; done;
	find ${PREFIX}/tmp -mindepth 1 -maxdepth 1 -not -iname \*.tar\* -exec rm -rf {} \;
	find ${PREFIX}/tmp -mindepth 1 -maxdepth 1 -type f -iname .\* -exec rm -rf {} \;
};

clean_build_status() {
	set -- BUILD_STATUS_IN_PROGRESS_FNAME BUILD_STATUS_PROGRESS_FNAME BUILD_STATUS_TARBALL_PROGRESS_FNAME;
	while [ ${#} -gt 0 ]; do
		unset ${1}; shift;
	done; touch ${PREFIX}/BUILD_ABORTED_AT_$(date %Y-%m-%d-%H-%M-%S);
	log_msg fail "Build aborted at $(date %Y-%m-%d-%H-%M-%S).";
};

export_vars_subst() {
	_evs_pfx=${1}; _evs_pfx_new=${2}; shift 2;
	while [ ${#} -gt 0 ]; do
		if [ -n "${_evs_vval:=$(get_var_unsafe ${_evs_pfx}${1})}" ]; then
			export "${_evs_pfx_new}${1}=${_evs_vval}";
		fi; unset _evs_vval; shift;
	done; unset _evs_pfx _evs_pfx_new;
};

fetch_git() {
	rm_if_exists ${1};
	[ -d ${1} ] && (cd ${1} && git pull origin main)\
		|| git clone ${3} ${2} ${1};
};

rm_if_exists() {
	[ -z "${1#-m}" ] && { _rie_arg_m=1; shift; };
	[ -z "${1#-c}" ] && { _rie_arg_c=1; shift; };
	[ -d ${1} -o -f ${1} ] && rm -rf ${1};
	[ ${_rie_arg_m:-0} -eq 1 ] && { mkdir ${1}; unset _rie_arg_m; };
	[ ${_rie_arg_c:-0} -eq 1 ] && { cd ${1}; unset _rie_arg_c; };
	return 0;
};

rotate_files() {
	set -- $(find ${PREFIX} -mindepth 1 -maxdepth 1 -type f -iname "${1}" |\
			sort | sed -n $((${2}+1)),\$p);
	while [ ${#} -gt 0 ]; do
		rm -f "${1}"; shift;
	done;
};

set_env_vars() {
	_sev_val_new="${1}"; shift;
	while [ ${#} -gt 1 ]; do
		[ -z "${_sev_val_new}" ] && unset ${1} ||\
			export "${1}=${_sev_val_new}"; shift;
	done; unset _sev_val_new;
};


# Download GNU bash-style patch sets into ${2}-patches-extra and
# apply them to ${2} in the correct order.
apply_patches() {
	(rm_if_exists -m -c ${2}-patches-extra;
	wget -c -nd -np -r -R \*.htm\* -R \*.sig ${1};
	for _ap_patch_fname in		\
			$(find . -type f -not -iname \*.sig | sort); do
		patch -b -d ../${2} -p0 < ${_ap_patch_fname};
	done; unset _ap_patch_fname);
};

# Check whether all supplied arguments contain non-empty valid values.
check_path_vars() {
	while [ ${#} -gt 0 ]; do
		if [ -z "${_cpv_val:=$(get_var_unsafe "${1}")}" ]; then
			log_msg failexit "Error: variable \`${1}' is empty or unset.";
		elif match_any "${_cpv_val}" " "; then
			log_msg failexit "Error: variable \`${1}' contains one or more whitespace characters.";
		else
			shift;
		fi;
		unset _cpv_val;
	done;
};

# Check whether all supplied command names resolve.
check_prereqs() {
	while [ ${#} -gt 0 ]; do
		if ! command -v ${1} >/dev/null; then
			log_msg failexit "Error: missing prerequisite command \`${1}'.";
		fi; shift;
	done;
};

# Clear the environment by unsetting each exported variable except
# for those named by the caller. 
clear_env_with_except() {
	_cewe_vfilter="${*}"; _cewe_unset_cmds="$(mktemp -q)";
	export | while read _cewe_vspec; do
		set -- ${_cewe_vspec}; shift;
		[ "${1#*[^\"\'=a-zA-Z0-9_]}" != "${1}" ] && continue;
		if ! match_list "${_cewe_vfilter}" " "	\
				$(get_prefix_lrg ${1} =); then
			echo unset $(get_prefix_lrg ${1} =) >> ${_cewe_unset_cmds};
		fi;
	done; . "${_cewe_unset_cmds}"; rm -f "${_cewe_unset_cmds}" 2>/dev/null;
	unset _cewe_vfilter _cewe_vspec;
};

fetch() {
	[ ${ARG_NO_DOWNLOAD:-0} -eq 0 ] &&\
		rm_if_exists $(get_basename ${1});
	wget ${WGET_ARGS} ${1};
	if [ ${#} -eq 2 ]; then
		set -- $(get_basename ${1}) "$(compare_hash $(get_basename ${1}) ${2})" ${2};
		if [ -n "${2}" ]; then
			log_msg failexit "Error: hash mismatch for URL \`${1}' (is: ${2}, should be: ${3}.)";
		fi;
	fi;
};

compare_hash() {
	# Push the output of dgst(1SSL) and the caller-supplied hash
	# value to compare the former with on the pseudo-stack and
	# shift off# all but the last two positional parameters.
	# This corresponds to the hash output and caller-supplied
	# hash values.
	set -- $(openssl dgst -sha256 ${1}) ${2}; shift $((${#}-2));
	[ "${1}" = "${2}" ] || echo "${1}";
};
compare_hash_manifest() {
	while [ ${#} -gt 0 ]; do
		if ! compare_hash ${1} ${2}; then
			log_msg failexit "Error: hash mismatch for patch file \`${1}'.";
		fi; shift;
	done; return 0;
};

is_build_script_done() {
	if [ -n "${ARG_RESTART_SCRIPT_AT}" ]; then
		if [ "${1}" = clean ]\
		&& [ -z "${ARG_RESTART_SCRIPT_AT#ALL}" ]; then
			return 0;	# Skip
		elif [ "${1}" = finish ]\
		|| [ -z "${ARG_RESTART_SCRIPT_AT#ALL}" ]; then
			return 1;	# Build
		elif ! match_list ${ARG_RESTART_SCRIPT_AT} , ${1}; then
			return 0;	# Skip
		else
			return 1;	# Build
		fi;
	elif [ -f ${WORKDIR}/.${2:-$(get_basename ${SCRIPT_FNAME%.build})}.${1} ]; then
		return 0;		# Skip
	else
		return 1;		# Build
	fi;
};
set_build_script_done() {
	_sbsd_script_fname=${SCRIPT_FNAME##*/};
	_sbsd_done_fname=${WORKDIR}/.${_sbsd_script_fname%.build};
	while [ $# -ge 1 ]; do
		if [ "${1#-}" != "${1}" ]; then
			rm -f ${_sbsd_done_fname}.${1#-};
		else
			touch ${_sbsd_done_fname}.${1};
			log_msg info "Finished build step ${1} of build script \`${_sbsd_script_fname}'.";
		fi; shift;
	done; unset _sbsd_script_fname _sbsd_done_fname;
};

log_env_vars() {
	log_msg info "Variables for this build:";
	while [ ${_lev_nvar:=0} -lt ${#} ]; do
		_lev_arg="$(eval echo \${${_lev_nvar}})";
		_lev_arg="${_lev_arg%%=*}";
		if [ ${#_lev_arg} -gt ${_lev_arg_len_max:=0} ]; then
			_lev_arg_len_max=${#_lev_arg};
		fi; : $((_lev_nvar+=1));
	done; unset _lev_nvar _lev_arg;
	while [ ${#} -gt 0 ]; do
		log_msg info "$(printf					\
			"%${_lev_arg_len_max}.${_lev_arg_len_max}s=%s"	\
			"${1%%=*}" "$(get_var_unsafe ${1#*=})")";
		shift;
	done; unset _lev_arg_len_max;
};
log_msg() {
	_lm_lvl=${1}; shift;
	case ${_lm_lvl} in
		failexit) printf "\033[${LOG_MSG_FAIL_COLOUR}m"; ;;
		fail) printf "\033[${LOG_MSG_FAIL_COLOUR}m"; ;;
		info) printf "\033[${LOG_MSG_INFO_COLOUR}m"; ;;
		succ) printf "\033[${LOG_MSG_SUCC_COLOUR}m"; ;;
	esac;
	if [ $# -gt 1 ]; then
		printf "==> %s %s %s\033[0m\n" "$(date "${TIMESTAMP_FMT}")" "${1}" "$*";
	else
		printf "==> %s %s\033[0m\n" "$(date "${TIMESTAMP_FMT}")" "${1}";
	fi; [ ${_lm_lvl} = failexit ] && exit 1 || unset _lm_lvl;
};

match_list() {
	_ml_cmp="${3}"; push_IFS "${2}"; set -- ${1}; pop_IFS;
	while [ ${#} -gt 0 ]; do
		if [ "${1}" = "${_ml_cmp}" ]; then
			unset _ml_cmp; return 0;
		fi; shift;
	done; unset _ml_cmp; return 1;
};

parse_with_pkg_name() {
	PKG_LVL=${1}; PKG_NAME=${2}; shift 2;
	while [ ${#} -ge 0 ]; do
		if [ "${PKG_NAME}" = ${1} ]; then
			export_vars_subst PKG_LVL${PKG_LVL}_ PKG_ ${PKG_BUILD_VARS};
			export_vars_subst PKG_$(echo ${PKG_NAME} | tr a-z A-Z)_ PKG_ ${PKG_BUILD_VARS};
			[ -z "${PKG_URL}" ] && return 1;
			[ -z "${PKG_FNAME}" ] && PKG_FNAME=${PKG_URL##*/};
			[ -z "${PKG_SUBDIR}" ] && PKG_SUBDIR=${PKG_FNAME%%.tar*};
			[ -n "${PKG_ENV_VARS_EXTRA}" ] && export ${PKG_ENV_VARS_EXTRA};
			export PKG_PREFIX=$(get_var_unsafe PREFIX_LVL${PKG_LVL}); return 0;
		fi; shift;
	done; return 1;
};

run_cmd_unsplit() {
	_rcu_cmd=${1}; shift;
	while [ ${#} -gt 0 ]; do
		[ -n "${1}" ] &&\
			_rcu_cmdline="${_rcu_cmdline:+${_rcu_cmdline},}${1}";
		shift;
	done;
	push_IFS ,; ${_rcu_cmd} ${_rcu_cmdline}; _rcu_rc=$?; pop_IFS;
	unset _rcu_cmd _rcu_cmdline; return ${_rcu_rc};
};

update_build_status() {
	while [ ${#} -gt 0 ]; do
	case ${1} in
	build_start)
		touch ${BUILD_STATUS_IN_PROGRESS_FNAME};
		touch ${BUILD_STATUS_PROGRESS_FNAME:=${PREFIX}/BUILD_STARTED_AT_${BUILD_DATE_START:=$(date %Y-%m-%d-%H-%M-%S)}};
		;;
	build_finish)
		[ -f ${BUILD_STATUS_PROGRESS_FNAME} ] &&\
			rm -f ${BUILD_STATUS_PROGRESS_FNAME};
		touch ${BUILD_STATUS_FINISHED_AT_FNAME:=${PREFIX}/BUILD_FINISHED_AT_$(date ${TIMESTAMP_FMT_STATUS_FILES})};
		rotate_files BUILD_FINISHED_AT_\* 8;
		ln -sf ${BUILD_STATUS_FINISHED_AT_FNAME}\
			${BUILD_STATUS_FINISHED_AT_CURRENT_FNAME}; ;;
	tarball_start)
		rotate_files midipix.\*.tar.bz2 8;
		touch ${BUILD_STATUS_TARBALL_PROGRESS_FNAME:=${PREFIX}/TARBALL_STARTED_AT_$(date ${TIMESTAMP_FMT_STATUS_FILES})};
		;;
	tarball_finish)
		[ -f ${BUILD_STATUS_TARBALL_PROGRESS_FNAME} ] &&\
			rm -f ${BUILD_STATUS_TARBALL_PROGRESS_FNAME}; ;;
	finish)
		[ -f ${BUILD_STATUS_IN_PROGRESS_FNAME} ] &&\
			rm -f ${BUILD_STATUS_IN_PROGRESS_FNAME}; ;;
	esac; shift;
	done;
};

# vim:filetype=sh
