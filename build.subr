#
# . ./build.vars and set -o errexit are assumed.
# See warning at the top of build.vars.
#

date() { command date +"${1:-${TIMESTAMP_FMT}}"; };
fetch_git() { [ -d ${1} ] && (cd ${1} && git pull origin main) || git clone ${3} ${2} ${1}; };
get_basename() { set -- $(get_name_without_slash ${1}); echo "${1##*/}"; };
get_var() { eval echo \${${1}}; }; # XXX
set_var() { eval ${1}=\"${2}\"; }; # XXX
get_name_without_slash() { while [ "x${1%/}" != "x${1}" ]; do set -- ${1%/}; done; echo ${1}; };
get_postfix_lrg() { echo "${1##*${2}}"; };
get_prefix_lrg() { echo "${1%%${2}*}"; };
get_postfix() { echo "${1#*${2}}"; };
get_prefix() { echo "${1%${2}*}"; };
match_any() { [ "x${1#*${2}*}" != "x${1}" ]; };
match_start() { [ "x${1#${2}}" != "x${1}" ]; };
push_IFS() { _pI_IFS="${IFS}"; IFS="${1}"; };
pop_IFS() { IFS="${_pI_IFS}"; unset _pI_IFS; };
set_build_dir() { PKG_BUILD_DIR=${1}-${2}-${TARGET}; };
split() { push_IFS "${1}"; set -- ${2}; pop_IFS; echo "${*}"; };
test_cmd() { command -v "${1}" >/dev/null; };
unsplit() { push_IFS "${1}"; shift; set -- "${@}"; echo "${*}"; pop_IFS; };


export_vars_subst() {
	_evs_pfx=${1}; _evs_pfx_new=${2}; shift 2;
	while [ ${#} -gt 0 ]; do
		if [ -n "${_evs_vval:=$(get_var ${_evs_pfx}${1})}" ]; then
			export "${_evs_pfx_new}${1}=${_evs_vval}";
		fi; unset _evs_vval; shift;
	done; unset _evs_pfx _evs_pfx_new;
};

rm_if_exists() {
	set_flag_vars_from_args "$@"; shift ${_sfvfa_nshift:-0};
	[ -d ${1} ] && rm -rf ${1}; [ -f ${1} ] && rm -f ${1};
	[ ${_arg_m:-0} -eq 1 ] && mkdir ${1};
	[ ${_arg_c:-0} -eq 1 ] && cd ${1};
	unset_flag_vars_from_args;
};

set_flag_vars_from_args() {
	unset _sfvfa_flag_vars _sfvfa_nshift;
	while [ ${#} -gt 1 ]; do
		if [ "x${1%[a-z]}" = "x-" ]; then
			set_var _arg_${1#-} 1;
			_sfvfa_flag_vars="${_sfvfa_flag_vars:+${_sfvfa_flag_vars} }_arg_${1#-}";
			: $((_sfvfa_nshift+=1));
		fi; shift;
	done;
};
unset_flag_vars_from_args() {
	set -- ${_sfvfa_flag_vars}; while [ ${#} -gt 0 ]; do
		unset ${1}; shift; done; unset _sfvfa_flag_vars _sfvfa_nshift;
};

set_env_vars() {
	_sev_val_new="${1}"; shift;
	while [ ${#} -gt 1 ]; do
		[ -z "${_sev_val_new}" ] && unset ${1} ||\
			export "${1}=${_sev_val_new}"; shift;
	done; unset _sev_val_new;
};


# Download GNU bash-style patch sets into ${2}-patches-extra and
# apply them to ${2} in the correct order.
apply_patches() {
	(rm_if_exists -m -c ${2}-patches-extra;
	wget -c -nd -np -r -R \*.htm\* -R \*.sig ${1};
	for _ap_patch_fname in		\
			$(find . -type f -not -iname \*.sig | sort); do
		patch -b -d ../${2} -p0 < ${_ap_patch_fname};
	done; unset _ap_patch_fname);
};

# Check whether all supplied arguments contain non-empty valid values.
check_path_vars() {
	while [ ${#} -gt 0 ]; do
		if [ -z "${_cpv_val:=$(get_var "${1}")}" ]; then
			log_msg failexit "Error: variable \`${1}' is empty or unset.";
		elif match_any "${_cpv_val}" " "; then
			log_msg failexit "Error: variable \`${1}' contains one or more whitespace characters.";
		else
			shift;
		fi;
		unset _cpv_val;
	done;
};

# Check whether all supplied command names resolve.
check_prereqs() {
	while [ ${#} -gt 0 ]; do
		if ! command -v ${1} >/dev/null; then
			log_msg failexit "Error: missing prerequisite command \`${1}'.";
		fi; shift;
	done;
};

# Clear the environment by unsetting each exported variable except
# for those named by the caller. 
clear_env_with_except() {
	_cewe_vfilter="${*}"; _cewe_unset_cmds="$(mktemp -q)";
	export | while read _cewe_vspec; do
		set -- ${_cewe_vspec}; shift;
		if ! match_list "${_cewe_vfilter}" " "	\
				$(get_prefix_lrg ${1} =); then
			echo unset $(get_prefix_lrg ${1} =) >> ${_cewe_unset_cmds};
		fi;
	done; . "${_cewe_unset_cmds}"; rm -f "${_cewe_unset_cmds}" 2>/dev/null;
	unset _cewe_vfilter _cewe_vspec;
};

fetch() {
	wget ${WGET_ARGS} ${1};
	if [ ${#} -eq 2 ]; then
		set -- $(get_basename ${1}) "$(compare_hash $(get_basename ${1}) ${2})" ${2};
		if [ -n "${2}" ]; then
			log_msg failexit "Error: hash mismatch for URL \`${1}' (is: ${2}, should be: ${3}.)";
		fi;
	fi;
};

compare_hash() {
	# Push the output of dgst(1SSL) and the caller-supplied hash
	# value to compare the former with on the pseudo-stack and
	# shift off# all but the last two positional parameters.
	# This corresponds to the hash output and caller-supplied
	# hash values.
	set -- $(openssl dgst -sha256 ${1}) ${2}; shift $((${#}-2));
	[ "x${1}" = "x${2}" ] || echo "${1}";
};
compare_hash_manifest() {
	while [ ${#} -gt 0 ]; do
		if ! compare_hash ${1} ${2}; then
			log_msg failexit "Error: hash mismatch for patch file \`${1}'.";
		fi; shift;
	done; return 0;
};

is_build_script_done() {
	if [ -n "${ARG_BUILD_STEPS}" ]; then
		if [ "${ARG_BUILD_STEPS}" = "finish" ]\
		|| [ -z "${ARG_BUILD_STEPS#ALL}" ]; then
			return 1;	# Build
		elif ! match_list ${ARG_BUILD_STEPS} , ${1}; then
			return 0;	# Skip
		else
			return 1;	# Build
		fi;
	elif [ -f ${WORKDIR}/.${2:-$(get_basename ${SCRIPT_FNAME%.build})}.${1} ]; then
		return 0;		# Skip
	else
		return 1;		# Build
	fi;
};
set_build_script_done() {
	_sbsd_script_fname=${SCRIPT_FNAME##*/};
	_sbsd_done_fname=${WORKDIR}/.${_sbsd_script_fname%.build};
	while [ $# -ge 1 ]; do
		if [ "x${1#-}" != "x${1}" ]; then
			rm -f ${_sbsd_done_fname}.${1#-};
		else
			touch ${_sbsd_done_fname}.${1};
			log_msg info "Finished build step ${1} of build script \`${_sbsd_script_fname}'.";
		fi; shift;
	done; unset _sbsd_script_fname _sbsd_done_fname;
};

log_env_vars() {
	log_msg info "Variables for this build:";
	while [ ${_lev_nvar:=0} -lt ${#} ]; do
		_lev_arg="$(eval echo \${${_lev_nvar}})";
		_lev_arg="${_lev_arg%%=*}";
		if [ ${#_lev_arg} -gt ${_lev_arg_len_max:=0} ]; then
			_lev_arg_len_max=${#_lev_arg};
		fi; : $((_lev_nvar+=1));
	done; unset _lev_nvar _lev_arg;
	while [ ${#} -gt 0 ]; do
		log_msg info "$(printf					\
			"%${_lev_arg_len_max}.${_lev_arg_len_max}s=%s"	\
			"${1%%=*}" "$(get_var ${1#*=})")";
		shift;
	done; unset _lev_arg_len_max;
};
log_msg() {
	_lm_lvl=${1}; shift;
	case ${_lm_lvl} in
		failexit) printf "\033[${LOG_MSG_FAIL_COLOUR}m"; ;;
		fail) printf "\033[${LOG_MSG_FAIL_COLOUR}m"; ;;
		info) printf "\033[${LOG_MSG_INFO_COLOUR}m"; ;;
		succ) printf "\033[${LOG_MSG_SUCC_COLOUR}m"; ;;
	esac;
	if [ $# -gt 1 ]; then
		printf "==> %s %s %s\033[0m\n" "$(date "${TIMESTAMP_FMT}")" "${1}" "$*";
	else
		printf "==> %s %s\033[0m\n" "$(date "${TIMESTAMP_FMT}")" "${1}";
	fi; [ ${_lm_lvl} = failexit ] && exit 1 || unset _lm_lvl;
};

match_list() {
	_ml_cmp="${3}"; push_IFS "${2}"; set -- ${1}; pop_IFS;
	while [ ${#} -gt 0 ]; do
		if [ "x${1}" = "x${_ml_cmp}" ]; then
			unset _ml_cmp; return 0;
		fi; shift;
	done; unset _ml_cmp; return 1;
};

parse_args_into_vars() {
	_paiv_arg0="${1}"; _paiv_args_valid="${2}"; shift 2;
	while [ $# -gt 0 ]; do
		case "${1}" in
		--*)	_paiv_aname="${1#--}";
			if ! match_list "${_paiv_args_valid}" , "${_paiv_aname%%=*}"; then
				log_msg failexit "Unknown parameter --${_paiv_aname%%=*} specified.";
			elif match_start "${_paiv_aname}" "*="; then
				_paiv_aval="$(get_postfix "${_paiv_aname}" =)";
				_paiv_aname="$(get_prefix_lrg "${_paiv_aname}" =)";
			else
				_paiv_aval=1;
			fi;
			set_var $(echo arg_${_paiv_aname} | tr a-z- A-Z_) "${_paiv_aval}";
			shift; ;;
		*=*)	set_var "$(get_prefix_lrg "${1}" =)"\
				"$(get_postfix "${1}" =)"; shift; ;;
		*)	log_msg failexit "Invalid or unknown command line argument \`${1}'."; ;;
		esac;
	done; unset _paiv_arg0 _paiv_args_valid _paiv_aname _paiv_aval;
};

parse_with_pkg_name() {
	PKG_LVL=${1}; PKG_NAME=${2}; shift 2;
	while [ ${#} -ge 0 ]; do
		if [ "x${PKG_NAME}" = "x${1}" ]; then
			export_vars_subst PKG_LVL${PKG_LVL}_ PKG_ ${PKG_BUILD_VARS};
			export_vars_subst PKG_$(echo ${PKG_NAME} | tr a-z A-Z)_ PKG_ ${PKG_BUILD_VARS};
			[ -z "${PKG_URL}" ] && return 1;
			[ -z "${PKG_FNAME}" ] && PKG_FNAME=${PKG_URL##*/};
			[ -z "${PKG_SUBDIR}" ] && PKG_SUBDIR=${PKG_FNAME%%.tar*};
			[ -n "${PKG_ENV_VARS_EXTRA}" ] && export ${PKG_ENV_VARS_EXTRA};
			return 0;
		fi; shift;
	done; return 1;
};

run_cmd_unsplit() {
	_rcu_cmd=${1}; shift;
	while [ ${#} -gt 0 ]; do
		[ -n "${1}" ] &&\
			_rcu_cmdline="${_rcu_cmdline:+${_rcu_cmdline},}${1}";
		shift;
	done;
	push_IFS ,; ${_rcu_cmd} ${_rcu_cmdline}; _rcu_rc=$?; pop_IFS;
	unset _rcu_cmd _rcu_cmdline; return ${_rcu_rc};
};

# vim:filetype=sh
