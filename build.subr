#
# . ./build.vars and set -o errexit are assumed.
#

TIMESTAMP_FMT="${TIMESTAMP_FMT:-"%Y/%m/%d %H:%M:%S"}";

check_path_vars() {
	while [ $# -gt 0 ]; do
		if [ -z "${_val:=$(eval echo \${${1}})}" ]; then
			log_msg fail "Error: variable \`${1}' is empty or unset.";
			exit 1;
		elif [ "x${_val#* }" != "x${_val}" ]; then
			log_msg fail "Error: variable \`${1}' contains one or more whitespace characters.";
			exit 1;
		else
			shift;
		fi;
	done; unset _val;
};

check_prereqs() {
	for _cmd in "$@"; do
		if ! command -v ${_cmd} >/dev/null; then
			log_msg fail "Error: missing prerequisite command \`${_cmd}.";
			exit 1;
		fi;
	done; unset _cmd;
};

date() {
	command date +"${1:-${TIMESTAMP_FMT}}";
};

fetch() {
	wget --no-check-certificate -N ${1};
	if [ $# -eq 2 ] && ! compare_hash ${1##*/} ${2}; then
		log_msg fail "Error: hash mismatch for URL \`${1##*/}'.";
		exit 1;
	fi;
};

fetch_git() {
	if [ -d ${1} ]; then
		(cd ${1} && git pull origin main);
	else
		git clone ${2} ${1};
	fi;
};

compare_hash() {
	_hash_cmp=${2}; set -- $(openssl dgst -sha256 ${1});
	shift $((${#}-1)); set -- ${1} ${_hash_cmp}; unset _hash_cmp;
	[ "x${1}" = "x${2}" ];
};

is_build_script_done() {
	_script_fname=${SCRIPT_FNAME##*/};
	if [ -f ${WORKDIR}/.${_script_fname%.build}.${1} ]; then
		unset script_fname;
		return 0;
	else
		unset script_fname;
		return 1;
	fi;
};
set_build_script_done() {
	_script_fname=${SCRIPT_FNAME##*/};
	_done_fname=${WORKDIR}/.${_script_fname%.build};
	while [ $# -ge 1 ]; do
		if [ "x${1#-}" != "x${1}" ]; then
			rm -f ${_done_fname}.${1#-};
		else
			touch ${_done_fname}.${1};
			log_msg info "Finished build step ${1} of build script \`${_script_fname}'.";
		fi; shift;
	done;
	unset _script_fname _done_fname;
};

log_msg() {
	_lvl=${1}; shift;
	case ${_lvl} in
		fail) printf "\033[${LOG_MSG_FAIL_COLOUR}m"; ;;
		info) printf "\033[${LOG_MSG_INFO_COLOUR}m"; ;;
		succ) printf "\033[${LOG_MSG_SUCC_COLOUR}m"; ;;
	esac;
	if [ $# -gt 1 ]; then
		printf "==> %s %s %s\033[0m\n" "$(date "${TIMESTAMP_FMT}")" "${1}" "$*";
	else
		printf "==> %s %s\033[0m\n" "$(date "${TIMESTAMP_FMT}")" "${1}";
	fi;
	unset _lvl;
};

parse_with_pkg_name() {
	PKG_NAME=${1}; shift;
	while [ $# -ge 0 ]; do
		if [ "x${PKG_NAME}" = "x${1}" ]; then
			_pkg_NAME=$(echo "${PKG_NAME}" | tr a-z A-Z);
			for _vname in							\
					build_type configure_args configure_extra_args	\
					no_config_cache no_libtool_midipix		\
					patches_extra prefix prefix_extra sha256sum	\
					url version					\
					CC CFLAGS DESTDIR LDFLAGS; do
				_vNAME=$(echo "${_vname}" | tr a-z A-Z);
				if [ -n "${_vval:=$(eval echo \${PKG_${_pkg_NAME}_${_vNAME}})}" ]; then
					export PKG_${_vNAME}="${_vval}";
					if [ "x${_vname#[A-Z]}" != "x${_vname}" ]; then
						export ${_vname}="${_vval}";
					fi;
				else
					unset PKG_${_vNAME};
				fi; unset _vval;
			done; unset _pkg_NAME _vname _vNAME;
			if [ -z "${PKG_URL}" ]; then
				return 1;
			else
				PKG_FNAME=${PKG_URL##*/};
				PKG_SUBDIR=${PKG_FNAME%%.tar*};
				return 0;
			fi;
		fi; shift;
	done; return 1;
};

rm_if_exists() {
	while [ $# -gt 1 ]; do [ "x${1%[a-z]}" = "x-" ] &&\
		eval _${1#-}flag=1; shift; done;
	_dir=${1};
	if [ -d ${1} ]; then
		rm -rf ${1} || return 1;
	fi;
	if [ ${_mflag:-0} -eq 1 ]; then
		unset _mflag; mkdir ${1} || return 2;
	fi;
	if [ ${_cflag:-0} -eq 1 ]; then
		unset _cflag; cd ${1} || return 3;
	fi;
};

set_build_dir() {
	BUILD_DIR=${1}-${2}-${TARGET};
};

set_env_vars() {
	_val=${1}; shift;
	while [ $# -ge 1 ]; do
		export "${1}=${_val}"; shift;
	done; unset _val;
};

split() {
	_IFS="${IFS}"; IFS="${1}"; set -- ${2};
	IFS="${_IFS}"; echo "${*}"; unset _IFS;
};

# vim:filetype=sh
