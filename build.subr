#
# . ./build.vars and set -o errexit -o noglob are assumed.
# See warning at the top of build.vars.
#

date() { command date +"${1:-${TIMESTAMP_FMT}}"; };
get_var_unsafe() { eval echo \${${1}}; };
set_var_unsafe() { eval ${1}=\"${2}\"; };
push_IFS() { _pI_IFS="${IFS}"; IFS="${1}"; };
pop_IFS() { IFS="${_pI_IFS}"; unset _pI_IFS; };
set_build_dir() { PKG_BUILD_DIR=${1}-${2}-${TARGET}; };
split() { push_IFS "${1}"; set -- ${2}; pop_IFS; echo "${*}"; };
test_cmd() { command -v "${1}" >/dev/null; };
unsplit() { push_IFS "${1}"; shift; set -- "${@}"; echo "${*}"; pop_IFS; };

# N.B.	URLs ($1) may contain `?' or '&' characters.
fetch() {
	_f_url="${1}"; _f_sha256sum_src="${2}";
	_f_url_dst="${DLCACHEDIR}/$(basename "${_f_url}")";
	if [ -e ${_f_url_dst}.fetched ]; then
		unset _f_url _f_sha256sum_src _f_url_dst;
		return 0;
	else
		wget ${WGET_ARGS} -c -O ${_f_url_dst} "${_f_url}";
	fi;
	if [ -n "${_f_sha256sum_src}" ]; then
		set -- $(openssl dgst -sha256 ${_f_url_dst}); shift $((${#}-1));
		if [ "${_f_sha256sum_dst:=${1}}" != "${_f_sha256sum_src}" ]; then
			log_msg failexit "Error: hash mismatch for URL \`${_f_url}' (is: ${_f_sha256sum_dst}, should be: ${_f_sha256sum_src}.)";
		fi;
	fi;
	touch ${_f_url_dst}.fetched;
	unset _f_url _f_url_dst _f_sha256sum_src _f_sha256sum_dst;
};
fetch_git() {
	_fg_subdir="${1}"; _fg_url="${2}"; _fg_branch="${3}";
	if [ -e "${DLCACHEDIR}/${_fg_subdir}" ]; then
		cd ${DLCACHEDIR}/${_fg_subdir} &&\
			git pull origin ${_fg_branch:-main} && cd ${OLDPWD};
	else
		git clone ${_fg_url} ${DLCACHEDIR}/${_fg_subdir};
		if [ -n "${_fg_branch}" -a		\
		     \( -z "${_fg_branch#main}" \) -a	\
		     \( -z "${_fg_branch#master}" \) ]; then
			cd ${DLCACHEDIR}/${_fg_subdir} &&\
				git checkout -b ${_fg_branch} && cd ${OLDPWD};
		fi;
	fi;
	secure_rm ${_fg_subdir};
	echo cp -pr ${DLCACHEDIR}/${_fg_subdir} .;
	cp -pr ${DLCACHEDIR}/${_fg_subdir} .;
};

get_vars_unsafe() {
	while [ ${#} -gt 0 ]; do
		_gvu_vval="$(eval echo \${${1}})";
		[ -z "${_gvu_vval}" ] || _gvu_vval_="${_gvu_vval}";
		shift;
	done; echo "${_gvu_vval_}";
	unset _gvu_vval _gvu_vval_;
};

disable_build_script_link() {
	if [ -e ${1%.disabled}.disabled ]; then
		log_msg failexit "Error: build script already disabled.";
	elif [ ! -e ${1} ]; then
		log_msg failexit "Error: invalid or non-existent build script filename/level/name.";
	else
		echo mv -- ${1} ${1}.disabled;
		mv -- ${1} ${1}.disabled;
	fi;
}
enable_build_script_link() {
	if [ -e ${1%.disabled} ]; then
		log_msg failexit "Error: build script already enabled.";
	elif [ ! -e ${1%.disabled}.disabled ]; then
		log_msg failexit "Error: invalid or non-existent build script filename/level/name.";
	else
		echo mv -- ${1%.disabled}.disabled ${1%.disabled};
		mv -- ${1%.disabled}.disabled ${1%.disabled};
	fi;
}
insert_build_script_link() {
	_ibsl_fname=${1};
	_ibsl_level=${_ibsl_fname%%.*};
	_ibsl_name=${_ibsl_fname#*.}; _ibsl_name=${_ibsl_name%.build};
	if [ -z "${_ibsl_fname}" -o -z "${_ibsl_level}"				\
			-o -z "${_ibsl_name}" ]					\
			|| ! isnumber ${_ibsl_level}				\
			|| [ ${#_ibsl_level} != 3 ]; then
		log_msg failexit "Error: invalid or empty build script filename/level/name.";
	elif [ -e ${_ibsl_fname} ]; then
		log_msg failexit "Error: build script \`${_ibsl_fname}' already exists.";
	elif [ -z "$(find -maxdepth 1 -name ${_ibsl_level}.\* -printf '%P\n' -quit)" ]; then
		echo ln -s -- pkg.build ${_ibsl_fname};
		ln -s -- pkg.build ${_ibsl_fname};
		unset _ibsl_fname _ibsl_level _ibsl_name;
		return 0;
	else
		_ibsl_levels="$(find -maxdepth 1 -name	\
			 ${_ibsl_level%[0-9][0-9]}\[0-9\]\[0-9\].\*		\
			-printf '%P\n' | sort -nk1)";
	fi;
	for _ibsl_fname_cur in ${_ibsl_levels}; do
		if [ \( ${_ibsl_changed:=0} -eq 0 \) -a	\
				\( "${_ibsl_fname_cur%%.*}" -eq ${_ibsl_level} \) ]; then
			echo ln -s -- pkg.build ${_ibsl_fname};
			ln -s -- pkg.build ${_ibsl_fname};
			_ibsl_changed=1;
		fi;
		if [ ${_ibsl_changed:=0} -eq 1 ]; then
			if [ -z "$(find -maxdepth 1				\
					-name $((${_ibsl_fname_cur%%.*}+1)).\*	\
					-printf '%P\n' -quit)" ]; then
				_ibsl_last=1;
			fi;
			echo mv -- ${_ibsl_fname_cur}				\
				$((${_ibsl_fname_cur%%.*}+1)).${_ibsl_fname_cur#*.};
			mv -- ${_ibsl_fname_cur}				\
				$((${_ibsl_fname_cur%%.*}+1)).${_ibsl_fname_cur#*.};
			if [ ${_ibsl_last:-0} -eq 1 ]; then
				break;
			fi;
		fi;
	done;
	if [ ${_ibsl_changed:=0} -eq 0 ]; then
		log_msg failexit "Error: build level ${_ibsl_level} not in \`${_ibsl_levels}'.";
	else
		unset _ibsl_levels _ibsl_fname_cur _ibsl_changed _ibsl_last;
		unset _ibsl_fname _ibsl_level _ibsl_name;
	fi;
};
isnumber() {
	[ -z "${1}" ] && return 1 || _i_num=${1};
	while [ -n "${_i_num}" ]; do
		if [ "${_i_num#[0-9]}" = "${_i_num}" ]; then
			return 1;
		else
			_i_num="${_i_num#[0-9]}";
		fi;
	done; unset _i_num; return 0;
};
remove_build_script_link() {
	_rbsl_fname=${1};
	_rbsl_level=${_rbsl_fname%%.*};
	_rbsl_name=${_rbsl_fname#*.}; _rbsl_name=${_rbsl_name%.build};
	if [ -z "${_rbsl_fname}" -o -z "${_rbsl_level}"				\
			-o -z "${_rbsl_name}" ]					\
			|| ! isnumber ${_rbsl_level}				\
			|| [ ${#_rbsl_level} != 3 ]; then
		log_msg failexit "Error: invalid or empty build script filename/level/name.";
	elif [ ! -e ${_rbsl_fname} ]; then
		log_msg failexit "Error: build script \`${_rbsl_fname}' doesn't exist.";
	else for _rbsl_fname_cur in $(find -maxdepth 1				\
			-name ${_rbsl_level%[0-9][0-9]}\[0-9\]\[0-9\].\*	\
			-printf '%P\n' | sort -nk1); do
		_rbsl_fname_cur_level=${_rbsl_fname_cur%%.*};
		if [ ${_rbsl_fname_cur_level} -gt ${_rbsl_level} ]; then
			echo mv ${_rbsl_fname_cur}			\
				$(printf "%03u"				\
					$((${_rbsl_fname_cur_level#00}-1))).${_rbsl_fname_cur#*.};
		fi;
	done; fi;
};

is_build_script_done() {
	if [ -n "${ARG_RESTART_SCRIPT_AT}" ]; then
		if [ "${1}" = clean ]\
		&& [ -z "${ARG_RESTART_SCRIPT_AT#ALL}" ]; then
			return 0;	# Skip
		elif [ "${1}" = finish ]\
		|| [ -z "${ARG_RESTART_SCRIPT_AT#ALL}" ]; then
			return 1;	# Build
		elif ! match_list ${ARG_RESTART_SCRIPT_AT} , ${1}; then
			return 0;	# Skip
		else
			return 1;	# Build
		fi;
	elif [ -f "${WORKDIR}/.${2:-$(basename ${SCRIPT_FNAME%.build})}.${1}" ]; then
		return 0;		# Skip
	else
		return 1;		# Build
	fi;
};
set_build_script_done() {
	_sbsd_script_fname=${SCRIPT_FNAME##*/};
	_sbsd_done_fname=${WORKDIR}/.${_sbsd_script_fname%.build};
	while [ $# -ge 1 ]; do
		if [ "${1#-}" != "${1}" ]; then
			secure_rm ${_sbsd_done_fname}.${1#-};
		else
			touch ${_sbsd_done_fname}.${1};
			log_msg info "Finished build step ${1} of build script \`${_sbsd_script_fname}'.";
		fi; shift;
	done; unset _sbsd_script_fname _sbsd_done_fname;
};

log_env_vars() {
	log_msg info "Variables for this ${1:-build}:"; shift;
	while [ ${_lev_nvar:=0} -lt ${#} ]; do
		_lev_arg="$(eval echo \${${_lev_nvar}})";
		_lev_arg="${_lev_arg%%=*}";
		if [ ${#_lev_arg} -gt ${_lev_arg_len_max:=0} ]; then
			_lev_arg_len_max=${#_lev_arg};
		fi; : $((_lev_nvar+=1));
	done; unset _lev_nvar _lev_arg;
	while [ ${#} -gt 0 ]; do
		log_msg info "$(printf					\
			"%${_lev_arg_len_max}.${_lev_arg_len_max}s=%s"	\
			"${1%%=*}" "$(get_var_unsafe ${1#*=})")";
		shift;
	done; unset _lev_arg_len_max;
};

log_msg() {
	_lm_lvl=${1}; shift;
	case ${_lm_lvl} in
		failexit) printf "\033[0m\033[${LOG_MSG_FAIL_COLOUR}m"; ;;
		fail) printf "\033[0m\033[${LOG_MSG_FAIL_COLOUR}m"; ;;
		info) printf "\033[0m\033[${LOG_MSG_INFO_COLOUR}m"; ;;
		succ) printf "\033[0m\033[${LOG_MSG_SUCC_COLOUR}m"; ;;
		warn) printf "\033[0m\033[${LOG_MSG_WARN_COLOUR}m"; ;;
	esac;
	if [ $# -gt 1 ]; then
		printf "==> %s %s %s\033[0m\n" "$(date "${TIMESTAMP_FMT}")" "${1}" "$*";
	else
		printf "==> %s %s\033[0m\n" "$(date "${TIMESTAMP_FMT}")" "${1}";
	fi; [ ${_lm_lvl} = failexit ] && exit 1 || unset _lm_lvl;
};

match_list() {
	_ml_cmp="${3}"; push_IFS "${2}"; set -- ${1}; pop_IFS;
	while [ ${#} -gt 0 ]; do
		if [ "${1}" = "${_ml_cmp}" ]; then
			unset _ml_cmp; return 0;
		fi; shift;
	done; unset _ml_cmp; return 1;
};

parse_with_pkg_name() {
	PKG_LVL=${1}; PKG_NAME=${2}; shift 2;
	_pwpn_pkg_NAME=$(echo ${PKG_NAME} | tr a-z A-Z);
	if [ -z "$(get_var_unsafe PKG_${_pwpn_pkg_NAME}_URL)" ]; then
		unset _pwpn_pkg_NAME;
		log_msg failexit "Error: package \`${PKG_NAME}' missing in build.vars.";
	else
		for _pwpn_vname in ${PKG_BUILD_VARS}; do
			if [ -n "$(get_var_unsafe DEFAULT_${_pwpn_vname})" ]; then
				export "PKG_${_pwpn_vname}=$(get_var_unsafe DEFAULT_${_pwpn_vname})";
			fi;
			if [ -n "$(get_var_unsafe PKG_LVL${PKG_LVL}_${_pwpn_vname})" ]; then
				export "PKG_${_pwpn_vname}=$(get_var_unsafe PKG_LVL${PKG_LVL}_${_pwpn_vname})";
			fi;
			if [ "${BUILD}" = "debug" ]	\
			&& [ -n "$(get_var_unsafe PKG_${_pwpn_pkg_NAME}_${_pwpn_vname}_DEBUG)" ]; then
				export "PKG_${_pwpn_vname}=$(get_var_unsafe PKG_${_pwpn_pkg_NAME}_${_pwpn_vname}_DEBUG)";
			elif [ "${BUILD}" = "release" ]	\
			&& [ -n "$(get_var_unsafe PKG_${_pwpn_pkg_NAME}_${_pwpn_vname}_RELEASE)" ]; then
				export "PKG_${_pwpn_vname}=$(get_var_unsafe PKG_${_pwpn_pkg_NAME}_${_pwpn_vname}_RELEASE)";
			elif [ -n "$(get_var_unsafe PKG_${_pwpn_pkg_NAME}_${_pwpn_vname})" ]; then
				export "PKG_${_pwpn_vname}=$(get_var_unsafe PKG_${_pwpn_pkg_NAME}_${_pwpn_vname})";
			fi;
		done; unset _pwpn_vname;
	fi;
	[ -z "${PKG_FNAME}" ] && PKG_FNAME=${PKG_URL##*/};
	[ -z "${PKG_SUBDIR}" ] && PKG_SUBDIR=${PKG_FNAME%%.tar*};
	[ -n "${PKG_ENV_VARS_EXTRA}" ] && set_env_vars_with_sep : "${PKG_ENV_VARS_EXTRA}";
	for _pwpn_env_var in $(export); do
		if [ "${_pwpn_env_var#PKG_}" != "${_pwpn_env_var}" ]; then
			_pwpn_env_vars="${_pwpn_env_vars:+${_pwpn_env_vars} }${_pwpn_env_var%%=*}";
		fi;
	done;
	if [ -n "${_pwpn_env_vars}" ]; then
		log_env_vars "build script" ${_pwpn_env_vars};
	fi; unset _pwpn_pkg_NAME _pwpn_env_var _pwpn_env_vars;
};
set_env_vars_with_sep() {
	_sevws_sep=${1}; shift; push_IFS ${_sevws_sep}; set -- ${1};
	while [ ${#} -gt 0 ]; do
		export "${1}"; shift;
	done; unset _sevws_sep; pop_IFS;
};

secure_cd() {
	if [ \( -z "${1}" \) -o \( ! -e "${1}" \) ]; then
		return 1;
	else
		(cd "${1}"; [ "${PWD#${PREFIX_ROOT}}" = "${PWD}" ] &&\
			return 1 || return 0);
		if [ ${?} -eq 0 ]; then
			[ "${ARG_VERBOSE:-0}" -eq 1 ] &&\
				log_msg warn "Changing working directory to \`${1}'.";
			cd -- "${1}";
		else
			log_msg failexit "secure_cd() called with pathname \`${1}' not below \${PREFIX_ROOT} (${PREFIX_ROOT}). This is a bug.";
		fi;
	fi;
};
insecure_mkdir() {
	while [ ${#} -gt 0 ]; do
		if [ -z "${1}" ]; then
			return 1;
		elif [ ! -e "${1}" ]; then
			[ "${ARG_VERBOSE:-0}" -eq 1 ] &&\
				log_msg warn "Making directory \`${1}'.";
			mkdir -p -- "${1}";
		fi; shift;
	done;
};
secure_rm() {
	while [ ${#} -gt 0 ]; do
		if [ -z "${1}" ]; then
			return 1;
		elif [ -e "${1}" ]; then
			if [ -d "${1}" ]; then
				_sr_pname_check="${1}";
			else
				_sr_pname_check="$(dirname "${1}")";
			fi;
			(cd "${_sr_pname_check}"; [ "${PWD#${PREFIX_ROOT}}" = "${PWD}" ] &&\
				return 1 || return 0);
			if [ ${?} -eq 0 ]; then
				unset _sr_pname_check;
				[ "${ARG_VERBOSE:-0}" -eq 1 ] &&\
					log_msg warn "Removing directory or file \`${1}'.";
				rm -rf -- "${1}";
			else
				log_msg failexit "secure_rm() called with pathname \`${1}' not below \${PREFIX_ROOT} (${PREFIX_ROOT}). This is a bug.";
			fi;
		fi; shift;
	done;
};

run_cmd_unsplit() {
	_rcu_cmd=${1}; shift;
	while [ ${#} -gt 0 ]; do
		[ -n "${1}" ] &&\
			_rcu_cmdline="${_rcu_cmdline:+${_rcu_cmdline}:}${1}";
		shift;
	done;
	push_IFS :; ${_rcu_cmd} ${_rcu_cmdline}; _rcu_rc=$?; pop_IFS;
	unset _rcu_cmd _rcu_cmdline; return ${_rcu_rc};
};

# vim:filetype=sh
