#
# set -o errexit -o noglob are assumed.
# Order: no_complex, native, full
#

pkgp_musl_configure() {
	ex_build_fileop rm "${PKG_BASE_DIR}/${PKG_BUILD_DIR}";
	ex_build_fileop mkdir "${PKG_BASE_DIR}/${PKG_BUILD_DIR}";
	ex_build_fileop cd "${PKG_BASE_DIR}/${PKG_BUILD_DIR}";
	env	lz_cflags_cmdline=""			\
		lz_debug="yes"				\
	../lazy/lazy					\
		-a "${ARCH}"				\
		-c gcc					\
		-f "${PKG_PREFIX}"			\
		-n musl					\
		-p "../musl-${PKG_MUSL_VERSION}"	\
		-t "${lz_target}"			\
		-x config;
};

pkg_musl_no_complex_all() {
	local _install _restart_at="${1}";
	PKG_MUSL_VERSION="${PKG_MUSL_NO_COMPLEX_VERSION}";
	# Git clone what we need.
	pkg_fetch_git "lazy=${DEFAULT_GITROOT}/lazy";
	export lz_arch="${ARCH}" lz_cflags_debug="-O2" lz_target="${TARGET}";
	# Musl: build (no-complex)
	_install=install_no_complex;
	ex_pkg_state_build_dir "musl-${PKG_MUSL_VERSION}" cross;
	if ! ex_pkg_state_test "${PKG_NAME}" fetch "${_restart_at}"; then
		pkg_fetch_wget "http://www.musl-libc.org/releases/musl-${PKG_MUSL_VERSION}.tar.gz"	\
			"${PKG_MUSL_NO_COMPLEX_SHA256SUM}";
		ex_build_fileop rm "${PKG_BASE_DIR}/mmglue";
		pkg_fetch_git "mmglue=${DEFAULT_GITROOT}/mmglue";
		ex_pkg_state_push "${PKG_NAME}" fetch -extract;
	fi;
	if ! ex_pkg_state_test "${PKG_NAME}" extract "${_restart_at}"; then
		ex_build_fileop rm "musl-${PKG_MUSL_VERSION}";
		tar -C "${PKG_BASE_DIR}" -xf "${DLCACHEDIR}/musl-${PKG_MUSL_VERSION}.tar.gz";
		set +o noglob;
		 ex_build_fileop cp ${PKG_BASE_DIR}/mmglue/* "${PKG_BASE_DIR}/musl-${PKG_MUSL_VERSION}/";
		set -o noglob;
		ex_pkg_state_push "${PKG_NAME}" extract -configure;
	fi;
	if ! ex_pkg_state_test "${PKG_NAME}" configure "${_restart_at}"; then
		pkgp_musl_configure;
		ex_pkg_state_push "${PKG_NAME}" configure -build;
	else
		ex_build_fileop cd "${PKG_BUILD_DIR}";
	fi;
	if ! ex_pkg_state_test "${PKG_NAME}" build "${_restart_at}"; then
		./lazy -e "${_install}" -x build;
		ex_pkg_state_push "${PKG_NAME}" build finish;
	fi;
};

pkg_musl_native_all() {
	local _install _restart_at="${1}";
	PKG_MUSL_VERSION="${PKG_MUSL_NATIVE_VERSION}";
	# Git clone what we need.
	pkg_fetch_git "lazy=${DEFAULT_GITROOT}/lazy";
	export lz_arch="${ARCH}" lz_cflags_debug="-O2" lz_target="${TARGET}";
	# Musl: build (full)
	_install=install;
	ex_pkg_state_build_dir "musl-${PKG_MUSL_VERSION}" native;
	if ! ex_pkg_state_test "${PKG_NAME}" configure "${_restart_at}"; then
		pkgp_musl_configure;
		ex_pkg_state_push "${PKG_NAME}" configure -build;
	else
		ex_build_fileop cd "${PKG_BUILD_DIR}";
	fi;
	if ! ex_pkg_state_test "${PKG_NAME}" build "${_restart_at}"; then
		./lazy -e "${_install}" -x build;
		ex_build_fileop ln_symbolic ../lib/libc.so "${PKG_PREFIX}/bin/ldd";
		ex_pkg_state_push "${PKG_NAME}" build finish;
	fi;
};

pkg_musl_full_all() {
	local _install _restart_at="${1}";
	PKG_MUSL_VERSION="${PKG_MUSL_FULL_VERSION}";
	# Git clone what we need.
	pkg_fetch_git "lazy=${DEFAULT_GITROOT}/lazy";
	export lz_arch="${ARCH}" lz_cflags_debug="-O2" lz_target="${TARGET}";
	# Musl: build (full)
	_install=install;
	ex_pkg_state_build_dir "musl-${PKG_MUSL_VERSION}" cross;
	if ! ex_pkg_state_test "${PKG_NAME}" configure "${_restart_at}"; then
		pkgp_musl_configure;
		ex_pkg_state_push "${PKG_NAME}" configure -build;
	else
		ex_build_fileop cd "${PKG_BUILD_DIR}";
	fi;
	if ! ex_pkg_state_test "${PKG_NAME}" build "${_restart_at}"; then
		./lazy -e "${_install}" -x build;
		ex_pkg_state_push "${PKG_NAME}" build finish;
	fi;
};

# vim:filetype=sh
